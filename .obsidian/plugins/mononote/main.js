/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Mononote
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/plugin-info.ts
var PLUGIN_INFO = {
  "pluginVersion": "1.2.2",
  "pluginReleasedAt": "2024-06-24T14:29:11+0200"
};

// src/settings.ts
var import_obsidian = require("obsidian");
var MononoteSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.delayOptions = [
      100,
      150,
      200,
      300,
      500
    ];
    this.plugin = plugin;
  }
  display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Mononote Settings" });
    const delayOptionsRecord = this.delayOptions.reduce(
      (acc, current) => {
        acc[`${current}`] = `${current}ms`;
        return acc;
      },
      {}
    );
    new import_obsidian.Setting(containerEl).setName("Delay before applying tab switching rules").setDesc(`
        Depending on your machine and the size of your vault, Obsidian might need a bit of time before Mononote's tab switching rules can be applied.

        Example: If you load a note N1 in an tab T1, and N1 is already shown in in T2, Mononote should switch to T2. But if you experience Mononote switching to T2, and then immediately back to T1, that means Obsidian needs more time. In that case, try increasing the delay.`).addDropdown((dropdown) => {
      dropdown.addOptions(delayOptionsRecord).setValue(`${plugin.settings.delayInMs}`).onChange(
        async (value) => {
          plugin.settings.delayInMs = +value;
          await plugin.saveSettings();
          this.display();
        }
      );
    });
    const afoURL = "https://actions.work/actions-for-obsidian?ref=plugin-mononote";
    containerEl.createEl("div", {
      attr: {
        style: `
          border-radius: 0.5rem;
          border: 1px dashed var(--text-muted);
          color: var(--text-muted);
          display: grid;
          font-size: 85%;
          grid-gap: 1rem;
          grid-template-columns: auto 1fr;
          margin-top: 4rem;
          opacity: 0.75;
          padding: 1rem;
        `
      }
    }).innerHTML = `
        <a href="${afoURL}">
          <img
            src="https://actions.work/img/afo-icon.png"
            style="margin: -0.4rem -0.5rem -0.5rem 0; width: 5rem;"
            alt="Actions for Obsidian icon, a cog wheel on a glossy black background">
        </a>
        <span>
          Mononote is brought to you by
          <a href="${afoURL}"><strong>Actions for Obsidian</strong></a>,
          a macOS/iOS app made by the same developer as this plugin. AFO is the
          missing link between Obsidian and macOS&nbsp;/&nbsp;iOS: 50+ Shortcuts
          actions to bring your notes and your automations together.
          <a href="${afoURL}">Take a look!</a>
        </span>
      `;
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  delayInMs: 100
};
var Mononote = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.pluginName = `Plugin Mononote v${PLUGIN_INFO.pluginVersion}`;
    this.processors = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    const { workspace } = this.app;
    workspace.onLayoutReady(() => {
      this.registerEvent(
        workspace.on("active-leaf-change", this.onActiveLeafChange.bind(this))
      );
      console.log(`${this.pluginName} initialized`);
    });
    this.addSettingTab(new MononoteSettingsTab(this.app, this));
  }
  onunload() {
    console.log(`${this.pluginName} unloaded`);
  }
  async loadSettings() {
    this.settings = { ...DEFAULT_SETTINGS, ...await this.loadData() };
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async onActiveLeafChange(activeLeaf) {
    const { id } = activeLeaf;
    if (this.processors.has(id)) {
      this.logMsg(id, "\u274C Already processing leaf");
      return;
    }
    const processor = this.processActiveLeaf(activeLeaf);
    this.processors.set(id, processor);
    try {
      await processor;
    } finally {
      this.processors.delete(id);
      this.logMsg(id, "Finished processing");
    }
  }
  async processActiveLeaf(activeLeaf) {
    const leafID = activeLeaf.id;
    const logMsg = (label, payload = "") => this.logMsg(leafID, label, payload);
    logMsg(
      "Processing leaf",
      { file: activeLeaf.view.getState().file, parent: activeLeaf.parent.id }
    );
    const filePath = activeLeaf.view.getState().file;
    if (!filePath) {
      logMsg("Contains no file");
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      const { workspace } = this.app;
      const viewType = activeLeaf == null ? void 0 : activeLeaf.view.getViewType();
      const duplicateLeaves = workspace.getLeavesOfType(viewType).filter(
        (l) => {
          var _a;
          return l.parent.id === activeLeaf.parent.id && l.id !== leafID && ((_a = l.view) == null ? void 0 : _a.getState().file) === filePath;
        }
      ).sort((l1, l2) => {
        if (l1.activeTime === 0)
          return -1;
        if (l2.activeTime === 0)
          return 1;
        return l2.activeTime - l1.activeTime;
      });
      if (duplicateLeaves.length === 0) {
        logMsg("No duplicates found");
        return resolve();
      }
      const targetToFocus = duplicateLeaves.find((l) => l.pinned) || duplicateLeaves.find((l) => !l.pinned);
      setTimeout(() => {
        const ephemeralState = { ...activeLeaf.getEphemeralState() };
        const hasEphemeralState = Object.keys(ephemeralState).length > 0;
        if (activeLeaf.view.navigation && activeLeaf.history.backHistory.length > 0) {
          activeLeaf.history.back();
          logMsg("history.back");
        } else if (activeLeaf.pinned) {
          logMsg("pinned tab, not detaching");
          return resolve();
        } else {
          activeLeaf.detach();
          logMsg("detach");
        }
        setTimeout(() => {
          workspace.setActiveLeaf(targetToFocus, { focus: true });
          if (hasEphemeralState) {
            targetToFocus.setEphemeralState(ephemeralState);
          }
        }, this.settings.delayInMs);
        resolve();
      }, this.settings.delayInMs);
    });
  }
  logMsg(leafID, label, payload = "") {
  }
};
