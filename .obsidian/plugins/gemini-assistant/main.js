/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GeminiAssistantPlugin
});
module.exports = __toCommonJS(main_exports);

// src/Settings.ts
var import_obsidian2 = require("obsidian");

// src/GeminiModelSetting.ts
var import_obsidian = require("obsidian");
var GeminiModelSetting = class extends import_obsidian.Modal {
  constructor(plugin, prompt2, callback) {
    super(plugin.app);
    this.prompt = { ...prompt2 };
    this.callback = callback;
  }
  async onOpen() {
    this.contentEl.empty();
    this.titleEl.setText("Model Setting");
    if (this.prompt.type == "generative") {
      let p2 = this.prompt;
      new import_obsidian.Setting(this.contentEl).setName("Name").addText((text2) => {
        text2.setValue(p2.display || "");
        text2.inputEl.style.width = "400px";
        text2.onChange((text3) => {
          p2.display = text3;
        });
      });
      new import_obsidian.Setting(this.contentEl).setName("Scope").addDropdown((dropdown) => {
        dropdown.addOption("SELECTION" /* SELECTION */, "Selection");
        dropdown.addOption("DOCUMENT" /* DOCUMENT */, "Document");
        dropdown.setValue(p2.scope);
        dropdown.onChange((value) => {
          p2.scope = value;
        });
      });
    }
    new import_obsidian.Setting(this.contentEl).setName("Max output tokens").addSlider((slider) => {
      slider.setLimits(1, this.prompt.config.outputTokenLimit, 1);
      slider.setDynamicTooltip();
      slider.setValue(this.prompt.config.maxOutputTokens);
      slider.onChange((value) => {
        this.prompt.config.maxOutputTokens = value;
      });
    });
    new import_obsidian.Setting(this.contentEl).setName("Temperature").addSlider((slider) => {
      slider.setLimits(0, 1, 0.1);
      slider.setDynamicTooltip();
      slider.setValue(this.prompt.config.temperature);
      slider.onChange((value) => {
        this.prompt.config.temperature = value;
      });
    });
    new import_obsidian.Setting(this.contentEl).setName("Top P").addSlider((slider) => {
      slider.setLimits(0, 1, 0.05);
      slider.setDynamicTooltip();
      slider.setValue(this.prompt.config.topP);
      slider.onChange((value) => {
        this.prompt.config.topP = value;
      });
    });
    new import_obsidian.Setting(this.contentEl).setName("Top K").addText((text2) => {
      text2.setValue(this.prompt.config.topK.toString());
      text2.onChange((value) => {
        if (value.match(/^[1-9]\d*$/)) {
          this.prompt.config.topK = parseInt(value);
        } else {
          text2.setValue(this.prompt.config.topK.toString());
        }
      });
    });
    if (this.prompt.type == "generative") {
      let p2 = this.prompt;
      new import_obsidian.Setting(this.contentEl).setName("Prompt").addTextArea((text2) => {
        text2.setValue(p2.prompt);
        text2.inputEl.style.width = "400px";
        text2.inputEl.style.resize = "none";
        text2.onChange((text3) => {
          p2.prompt = text3;
        });
      });
    }
    new import_obsidian.Setting(this.contentEl).addButton((button) => {
      button.setButtonText("Close");
      button.onClick(() => {
        this.close();
      });
    }).addButton((button) => {
      button.setButtonText("Save");
      button.buttonEl.style.backgroundColor = "var(--interactive-accent)";
      button.onClick(() => {
        this.callback(this.prompt);
        this.close();
      });
    });
  }
};

// src/Settings.ts
var DEFAULT_GEMINI_CONFIGS = {
  "gemini-pro": {
    topK: 1,
    topP: 1,
    temperature: 0.9,
    outputTokenLimit: 2048,
    maxOutputTokens: 400,
    inputTokenLimit: 30720
  },
  "gemini-pro-vision": {
    topK: 32,
    topP: 1,
    temperature: 0.4,
    outputTokenLimit: 4096,
    maxOutputTokens: 400,
    inputTokenLimit: 12288
  }
};
var DEFAULT_SETTINGS = {
  apiKey: "",
  model: "gemini-pro",
  prompts: [
    {
      display: "Ask Gemini (Selection)",
      scope: "SELECTION" /* SELECTION */,
      model: "gemini-pro",
      config: DEFAULT_GEMINI_CONFIGS["gemini-pro"],
      prompt: "",
      type: "generative"
    },
    {
      display: "Ask Gemini (Document)",
      scope: "DOCUMENT" /* DOCUMENT */,
      model: "gemini-pro",
      config: DEFAULT_GEMINI_CONFIGS["gemini-pro"],
      prompt: "",
      type: "generative"
    }
  ],
  chat: {
    model: "gemini-pro",
    config: DEFAULT_GEMINI_CONFIGS["gemini-pro"],
    type: "chat"
  },
  saftyThreshold: "HARM_BLOCK_THRESHOLD_UNSPECIFIED"
};
var GeminiSettings = class extends import_obsidian2.PluginSettingTab {
  constructor(plugin, settings) {
    super(plugin.app, plugin);
    this.plugin = plugin;
    this.settings = settings;
  }
  async updateSettings(newSettings, refresh = false) {
    this.settings = { ...this.settings, ...newSettings };
    await this.plugin.saveData(this.settings);
    if (refresh) {
      this.display();
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("API Key").addText((text2) => {
      text2.setValue(this.settings.apiKey);
      text2.onChange((apiKey) => {
        this.updateSettings({ apiKey });
        this.plugin.updateApiKey(apiKey);
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Chat Setting").addExtraButton((button) => {
      button.setIcon("settings");
      button.setTooltip("Edit");
      button.onClick(() => {
        new GeminiModelSetting(
          this.plugin,
          this.settings.chat,
          (updated) => {
            this.updateSettings({ chat: updated }, true);
          }
        ).open();
      });
    });
    new import_obsidian2.Setting(containerEl).setHeading().setName("Model");
    new import_obsidian2.Setting(containerEl).setName("Harm Content Block Threshold").addDropdown((dropdown) => {
      dropdown.addOptions({
        HARM_BLOCK_THRESHOLD_UNSPECIFIED: "Default",
        BLOCK_LOW_AND_ABOVE: "Low",
        BLOCK_MEDIUM_AND_ABOVE: "Medium",
        BLOCK_ONLY_HIGH: "High",
        BLOCK_NONE: "None"
      });
      dropdown.setValue(this.settings.saftyThreshold);
      dropdown.onChange((value) => {
        this.updateSettings({ saftyThreshold: value });
      });
    });
    new import_obsidian2.Setting(containerEl).setHeading().setName("Prompts").addExtraButton((button) => {
      button.setIcon("plus");
      button.setTooltip("Add prompt");
      button.onClick(() => {
        let prompt2 = {
          display: "Custom Prompt",
          scope: "SELECTION" /* SELECTION */,
          model: "gemini-pro",
          config: DEFAULT_GEMINI_CONFIGS["gemini-pro"],
          prompt: "",
          type: "generative"
        };
        new GeminiModelSetting(this.plugin, prompt2, (n2) => {
          this.updateSettings(
            {
              prompts: [
                ...this.settings.prompts,
                n2
              ]
            },
            true
          );
        }).open();
      });
    });
    for (let i2 = 0; i2 < this.settings.prompts.length; i2++) {
      new import_obsidian2.Setting(containerEl).setName(this.settings.prompts[i2].display).addExtraButton((button) => {
        button.setIcon("settings");
        button.setTooltip("Edit");
        button.onClick(() => {
          new GeminiModelSetting(
            this.plugin,
            this.settings.prompts[i2],
            (updated) => {
              let prompts = [...this.settings.prompts];
              prompts[i2] = updated;
              this.plugin.updateSettings({ prompts }, true);
            }
          ).open();
        });
      }).addExtraButton((button) => {
        button.setIcon("trash");
        button.setTooltip("Remove");
        button.onClick(() => {
          this.settings.prompts.splice(i2, 1);
          this.updateSettings(
            { prompts: this.settings.prompts },
            true
          );
        });
      });
    }
  }
  getSettings() {
    return this.settings;
  }
};

// src/main.ts
var import_obsidian6 = require("obsidian");

// src/AssistantSuggestor.ts
var import_obsidian3 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function is_promise(value) {
  return !!value && (typeof value === "object" || typeof value === "function") && typeof /** @type {any} */
  value.then === "function";
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 && typeof a2 === "object" || typeof a2 === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e2) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e2;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
  targets.forEach((c2) => c2());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/await_block.js
function handle_promise(promise, info) {
  const token = info.token = {};
  function update2(type, index, key, value) {
    if (info.token !== token)
      return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i2) => {
          if (i2 !== index && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i2] === block2) {
                info.blocks[i2] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks)
      info.blocks[index] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise)) {
    const current_component2 = get_current_component();
    promise.then(
      (value) => {
        set_current_component(current_component2);
        update2(info.then, 1, info.value, value);
        set_current_component(null);
      },
      (error) => {
        set_current_component(current_component2);
        update2(info.catch, 2, info.error, error);
        set_current_component(null);
        if (!info.hasCatch) {
          throw error;
        }
      }
    );
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise);
      return true;
    }
    info.resolved = /** @type {T} */
    promise;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance4, create_fragment4, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance4 ? instance4(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// src/components/GeminiIcon.svelte
function create_fragment(ctx) {
  let svg;
  let path0;
  let path0_fill_value;
  let path1;
  let path1_fill_value;
  let defs;
  let radialGradient0;
  let stop0;
  let stop1;
  let stop2;
  let stop3;
  let stop4;
  let stop5;
  let radialGradient0_id_value;
  let radialGradient1;
  let stop6;
  let stop7;
  let stop8;
  let stop9;
  let stop10;
  let stop11;
  let radialGradient1_id_value;
  return {
    c() {
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      defs = svg_element("defs");
      radialGradient0 = svg_element("radialGradient");
      stop0 = svg_element("stop");
      stop1 = svg_element("stop");
      stop2 = svg_element("stop");
      stop3 = svg_element("stop");
      stop4 = svg_element("stop");
      stop5 = svg_element("stop");
      radialGradient1 = svg_element("radialGradient");
      stop6 = svg_element("stop");
      stop7 = svg_element("stop");
      stop8 = svg_element("stop");
      stop9 = svg_element("stop");
      stop10 = svg_element("stop");
      stop11 = svg_element("stop");
      attr(path0, "d", "M515.09 725.824l-43.084 98.679c-16.562 37.931-69.052 37.931-85.613 0l-43.085-98.679c-38.342-87.818-107.355-157.72-193.44-195.932l-118.59-52.641c-37.704-16.736-37.704-71.586 0-88.322l114.886-50.997c88.299-39.195 158.55-111.688 196.237-202.501l43.643-105.162c16.195-39.025 70.115-39.025 86.311 0l43.643 105.163c37.687 90.812 107.937 163.305 196.236 202.5l114.887 50.997c37.704 16.736 37.704 71.586 0 88.322L708.53 529.892c-86.084 38.212-155.097 108.114-193.44 195.932z");
      attr(path0, "fill", path0_fill_value = "url(#gemini_icon_" + /*id*/
      ctx[2] + ")");
      attr(path1, "d", "M915.485 1036.98l-12.118 27.77c-8.868 20.33-37.018 20.33-45.886 0l-12.117-27.77c-21.599-49.515-60.502-88.938-109.046-110.505l-37.331-16.586c-20.185-8.968-20.185-38.311 0-47.279l35.244-15.659c49.792-22.122 89.392-63.004 110.62-114.201l12.443-30.009c8.672-20.915 37.588-20.915 46.26 0l12.443 30.009c21.228 51.197 60.829 92.079 110.623 114.201l35.24 15.659c20.19 8.968 20.19 38.311 0 47.279l-37.33 16.586c-48.543 21.567-87.447 60.99-109.045 110.505z");
      attr(path1, "fill", path1_fill_value = "url(#gemini_icon_" + /*id*/
      ctx[2] + ")");
      attr(stop0, "stop-color", "#1BA1E3");
      attr(stop1, "offset", "0");
      attr(stop1, "stop-color", "#1BA1E3");
      attr(stop2, "offset", ".3");
      attr(stop2, "stop-color", "#5489D6");
      attr(stop3, "offset", ".546");
      attr(stop3, "stop-color", "#9B72CB");
      attr(stop4, "offset", ".825");
      attr(stop4, "stop-color", "#D96570");
      attr(stop5, "offset", "1");
      attr(stop5, "stop-color", "#F49C46");
      attr(radialGradient0, "id", radialGradient0_id_value = "gemini_icon_" + /*id*/
      ctx[2]);
      attr(radialGradient0, "cx", "0");
      attr(radialGradient0, "cy", "0");
      attr(radialGradient0, "r", "1");
      attr(radialGradient0, "gradientUnits", "userSpaceOnUse");
      attr(radialGradient0, "gradientTransform", "rotate(78.858 46.989 644.69) scale(665.5 665.824)");
      attr(stop6, "stop-color", "#1BA1E3");
      attr(stop7, "offset", "0");
      attr(stop7, "stop-color", "#1BA1E3");
      attr(stop8, "offset", ".3");
      attr(stop8, "stop-color", "#5489D6");
      attr(stop9, "offset", ".546");
      attr(stop9, "stop-color", "#9B72CB");
      attr(stop10, "offset", ".825");
      attr(stop10, "stop-color", "#D96570");
      attr(stop11, "offset", "1");
      attr(stop11, "stop-color", "#F49C46");
      attr(radialGradient1, "id", radialGradient1_id_value = "gemini_icon_" + /*id*/
      ctx[2]);
      attr(radialGradient1, "cx", "0");
      attr(radialGradient1, "cy", "0");
      attr(radialGradient1, "r", "1");
      attr(radialGradient1, "gradientUnits", "userSpaceOnUse");
      attr(radialGradient1, "gradientTransform", "rotate(78.858 46.989 644.69) scale(665.5 665.824)");
      attr(svg, "fill", "none");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 1080 1080");
      attr(
        svg,
        "width",
        /*width*/
        ctx[0]
      );
      attr(
        svg,
        "height",
        /*height*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path0);
      append(svg, path1);
      append(svg, defs);
      append(defs, radialGradient0);
      append(radialGradient0, stop0);
      append(radialGradient0, stop1);
      append(radialGradient0, stop2);
      append(radialGradient0, stop3);
      append(radialGradient0, stop4);
      append(radialGradient0, stop5);
      append(defs, radialGradient1);
      append(radialGradient1, stop6);
      append(radialGradient1, stop7);
      append(radialGradient1, stop8);
      append(radialGradient1, stop9);
      append(radialGradient1, stop10);
      append(radialGradient1, stop11);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*width*/
      1) {
        attr(
          svg,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      if (dirty & /*height*/
      2) {
        attr(
          svg,
          "height",
          /*height*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { width } = $$props;
  let { height } = $$props;
  const id = nanoid();
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
  };
  return [width, height, id];
}
var GeminiIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { width: 0, height: 1 });
  }
};
var GeminiIcon_default = GeminiIcon;

// src/components/SuggestionComponent.svelte
function add_css(target) {
  append_styles(target, "svelte-qtzjbo", ".gemini-option.svelte-qtzjbo{display:flex;justify-content:space-between}.token-normal.svelte-qtzjbo{font-size:0.6rem;color:var(--text-muted);align-self:flex-end}.token-exceed.svelte-qtzjbo{font-size:0.6rem;color:var(--text-error);align-self:flex-end}");
}
function create_catch_block(ctx) {
  let span;
  return {
    c() {
      span = element("span");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_then_block(ctx) {
  let span;
  let t_value = (
    /*count*/
    ctx[4] + ""
  );
  let t2;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
      attr(span, "class", span_class_value = null_to_empty(
        /*count*/
        ctx[4] > /*option*/
        ctx[0].config.inputTokenLimit ? "token-exceed" : "token-normal"
      ) + " svelte-qtzjbo");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*option*/
      1 && span_class_value !== (span_class_value = null_to_empty(
        /*count*/
        ctx2[4] > /*option*/
        ctx2[0].config.inputTokenLimit ? "token-exceed" : "token-normal"
      ) + " svelte-qtzjbo")) {
        attr(span, "class", span_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_pending_block(ctx) {
  let span;
  return {
    c() {
      span = element("span");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment2(ctx) {
  let div;
  let span1;
  let span0;
  let geminiicon;
  let t0;
  let t1_value = (
    /*option*/
    ctx[0].display + ""
  );
  let t1;
  let t2;
  let promise;
  let current;
  geminiicon = new GeminiIcon_default({ props: { width: "12px", height: "12px" } });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 4
  };
  handle_promise(promise = /*token*/
  ctx[1], info);
  return {
    c() {
      div = element("div");
      span1 = element("span");
      span0 = element("span");
      create_component(geminiicon.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      info.block.c();
      attr(div, "class", "gemini-option svelte-qtzjbo");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span1);
      append(span1, span0);
      mount_component(geminiicon, span0, null);
      append(span1, t0);
      append(span1, t1);
      append(div, t2);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & /*option*/
      1) && t1_value !== (t1_value = /*option*/
      ctx[0].display + ""))
        set_data(t1, t1_value);
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(geminiicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(geminiicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(geminiicon);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { option } = $$props;
  let { gemini } = $$props;
  const prompt2 = option.prompt;
  const token = gemini.countToken(prompt2);
  $$self.$$set = ($$props2) => {
    if ("option" in $$props2)
      $$invalidate(0, option = $$props2.option);
    if ("gemini" in $$props2)
      $$invalidate(2, gemini = $$props2.gemini);
  };
  return [option, token, gemini];
}
var SuggestionComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { option: 0, gemini: 2 }, add_css);
  }
};
var SuggestionComponent_default = SuggestionComponent;

// src/AssistantSuggestor.ts
var AssistantSuggestor = class extends import_obsidian3.SuggestModal {
  constructor(plugin, editor, view) {
    super(plugin.app);
    this.query = "";
    this.plugin = plugin;
    this.editor = editor;
    this.inputEl.placeholder = "Prompt...";
    this.gemini = plugin.gemini;
    this.view = view.editor.cm;
    this.open();
  }
  getSuggestions(query) {
    this.query = query;
    return this.plugin.getSettings().prompts.map((option) => {
      const prompt2 = this.getPrompt(option);
      return {
        ...option,
        prompt: prompt2
      };
    });
  }
  renderSuggestion(option, el) {
    var _a;
    new SuggestionComponent_default({
      target: el,
      props: {
        option,
        gemini: (_a = this.gemini) == null ? void 0 : _a.gemini
      }
    });
  }
  async onChooseSuggestion(option, evt) {
    var _a;
    (_a = this.gemini) == null ? void 0 : _a.generate(this.view, option);
    this.query = "";
  }
  getPrompt(option) {
    const prompt2 = [];
    if (this.query) {
      prompt2.push(this.query);
    }
    if (option.prompt) {
      prompt2.push(option.prompt);
    }
    if (option.scope == "DOCUMENT" /* DOCUMENT */) {
      const doc = this.editor.getValue();
      if (doc) {
        prompt2.push(doc);
      }
    }
    if (option.scope == "SELECTION" /* SELECTION */) {
      const selection = this.editor.getSelection();
      if (selection) {
        prompt2.push(selection);
      }
    }
    return prompt2;
  }
};

// src/GeminiExtension.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");

// src/generative-ai.mjs
var t;
var e;
var n;
var s;
var i;
var o;
!function(t2) {
  t2.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED", t2.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH", t2.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT", t2.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT", t2.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT";
}(t || (t = {})), function(t2) {
  t2.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED", t2.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", t2.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", t2.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", t2.BLOCK_NONE = "BLOCK_NONE";
}(e || (e = {})), function(t2) {
  t2.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED", t2.NEGLIGIBLE = "NEGLIGIBLE", t2.LOW = "LOW", t2.MEDIUM = "MEDIUM", t2.HIGH = "HIGH";
}(n || (n = {})), function(t2) {
  t2.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED", t2.SAFETY = "SAFETY", t2.OTHER = "OTHER";
}(s || (s = {})), function(t2) {
  t2.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED", t2.STOP = "STOP", t2.MAX_TOKENS = "MAX_TOKENS", t2.SAFETY = "SAFETY", t2.RECITATION = "RECITATION", t2.OTHER = "OTHER";
}(i || (i = {})), function(t2) {
  t2.TASK_TYPE_UNSPECIFIED = "TASK_TYPE_UNSPECIFIED", t2.RETRIEVAL_QUERY = "RETRIEVAL_QUERY", t2.RETRIEVAL_DOCUMENT = "RETRIEVAL_DOCUMENT", t2.SEMANTIC_SIMILARITY = "SEMANTIC_SIMILARITY", t2.CLASSIFICATION = "CLASSIFICATION", t2.CLUSTERING = "CLUSTERING";
}(o || (o = {}));
var r = class extends Error {
  constructor(t2) {
    super(`[GoogleGenerativeAI Error]: ${t2}`);
  }
};
var a = class extends r {
  constructor(t2, e2) {
    super(t2), this.response = e2;
  }
};
var c = "0.2.1";
var d = "genai-js";
var u;
!function(t2) {
  t2.GENERATE_CONTENT = "generateContent", t2.STREAM_GENERATE_CONTENT = "streamGenerateContent", t2.COUNT_TOKENS = "countTokens", t2.EMBED_CONTENT = "embedContent", t2.BATCH_EMBED_CONTENTS = "batchEmbedContents";
}(u || (u = {}));
var h = class {
  constructor(t2, e2, n2, s2) {
    this.model = t2, this.task = e2, this.apiKey = n2, this.stream = s2;
  }
  toString() {
    let t2 = `https://generativelanguage.googleapis.com/v1/${this.model}:${this.task}`;
    return this.stream && (t2 += "?alt=sse"), t2;
  }
};
async function E(t2, e2, n2) {
  let s2;
  try {
    if (s2 = await fetch(t2.toString(), Object.assign(Object.assign({}, function(t3) {
      const e3 = {};
      if ((null == t3 ? void 0 : t3.timeout) >= 0) {
        const n3 = new AbortController(), s3 = n3.signal;
        setTimeout(() => n3.abort(), t3.timeout), e3.signal = s3;
      }
      return e3;
    }(n2)), { method: "POST", headers: { "Content-Type": "application/json", "x-goog-api-client": `${d}/${c}`, "x-goog-api-key": t2.apiKey }, body: e2 })), !s2.ok) {
      let t3 = "";
      try {
        const e3 = await s2.json();
        t3 = e3.error.message, e3.error.details && (t3 += ` ${JSON.stringify(e3.error.details)}`);
      } catch (t4) {
      }
      throw new Error(`[${s2.status} ${s2.statusText}] ${t3}`);
    }
  } catch (e3) {
    const n3 = new r(`Error fetching from ${t2.toString()}: ${e3.message}`);
    throw n3.stack = e3.stack, n3;
  }
  return s2;
}
function l(t2) {
  return t2.text = () => {
    if (t2.candidates && t2.candidates.length > 0) {
      if (t2.candidates.length > 1 && console.warn(`This response had ${t2.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`), _(t2.candidates[0]))
        throw new a(`${p(t2)}`, t2);
      return function(t3) {
        var e2, n2, s2, i2;
        return (null === (i2 = null === (s2 = null === (n2 = null === (e2 = t3.candidates) || void 0 === e2 ? void 0 : e2[0].content) || void 0 === n2 ? void 0 : n2.parts) || void 0 === s2 ? void 0 : s2[0]) || void 0 === i2 ? void 0 : i2.text) ? t3.candidates[0].content.parts[0].text : "";
      }(t2);
    }
    if (t2.promptFeedback)
      throw new a(`Text not available. ${p(t2)}`, t2);
    return "";
  }, t2;
}
var f = [i.RECITATION, i.SAFETY];
function _(t2) {
  return !!t2.finishReason && f.includes(t2.finishReason);
}
function p(t2) {
  var e2, n2, s2;
  let i2 = "";
  if (t2.candidates && 0 !== t2.candidates.length || !t2.promptFeedback) {
    if (null === (s2 = t2.candidates) || void 0 === s2 ? void 0 : s2[0]) {
      const e3 = t2.candidates[0];
      _(e3) && (i2 += `Candidate was blocked due to ${e3.finishReason}`, e3.finishMessage && (i2 += `: ${e3.finishMessage}`));
    }
  } else
    i2 += "Response was blocked", (null === (e2 = t2.promptFeedback) || void 0 === e2 ? void 0 : e2.blockReason) && (i2 += ` due to ${t2.promptFeedback.blockReason}`), (null === (n2 = t2.promptFeedback) || void 0 === n2 ? void 0 : n2.blockReasonMessage) && (i2 += `: ${t2.promptFeedback.blockReasonMessage}`);
  return i2;
}
function g(t2) {
  return this instanceof g ? (this.v = t2, this) : new g(t2);
}
function O(t2, e2, n2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var s2, i2 = n2.apply(t2, e2 || []), o2 = [];
  return s2 = {}, r2("next"), r2("throw"), r2("return"), s2[Symbol.asyncIterator] = function() {
    return this;
  }, s2;
  function r2(t3) {
    i2[t3] && (s2[t3] = function(e3) {
      return new Promise(function(n3, s3) {
        o2.push([t3, e3, n3, s3]) > 1 || a2(t3, e3);
      });
    });
  }
  function a2(t3, e3) {
    try {
      (n3 = i2[t3](e3)).value instanceof g ? Promise.resolve(n3.value.v).then(c2, d2) : u2(o2[0][2], n3);
    } catch (t4) {
      u2(o2[0][3], t4);
    }
    var n3;
  }
  function c2(t3) {
    a2("next", t3);
  }
  function d2(t3) {
    a2("throw", t3);
  }
  function u2(t3, e3) {
    t3(e3), o2.shift(), o2.length && a2(o2[0][0], o2[0][1]);
  }
}
var T = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
function S(t2) {
  const e2 = function(t3) {
    const e3 = t3.getReader();
    return new ReadableStream({ start(t4) {
      let n3 = "";
      return s3();
      function s3() {
        return e3.read().then(({ value: e4, done: i2 }) => {
          if (i2)
            return n3.trim() ? void t4.error(new r("Failed to parse stream")) : void t4.close();
          n3 += e4;
          let o2, a2 = n3.match(T);
          for (; a2; ) {
            try {
              o2 = JSON.parse(a2[1]);
            } catch (e5) {
              return void t4.error(new r(`Error parsing JSON response: "${a2[1]}"`));
            }
            t4.enqueue(o2), n3 = n3.substring(a2[0].length), a2 = n3.match(T);
          }
          return s3();
        });
      }
    } });
  }(t2.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }))), [n2, s2] = e2.tee();
  return { stream: m(n2), response: y(s2) };
}
async function y(t2) {
  const e2 = [], n2 = t2.getReader();
  for (; ; ) {
    const { done: t3, value: s2 } = await n2.read();
    if (t3)
      return l(C(e2));
    e2.push(s2);
  }
}
function m(t2) {
  return O(this, arguments, function* () {
    const e2 = t2.getReader();
    for (; ; ) {
      const { value: t3, done: n2 } = yield g(e2.read());
      if (n2)
        break;
      yield yield g(l(t3));
    }
  });
}
function C(t2) {
  const e2 = t2[t2.length - 1], n2 = { promptFeedback: null == e2 ? void 0 : e2.promptFeedback };
  for (const e3 of t2)
    if (e3.candidates)
      for (const t3 of e3.candidates) {
        const e4 = t3.index;
        if (n2.candidates || (n2.candidates = []), n2.candidates[e4] || (n2.candidates[e4] = { index: t3.index }), n2.candidates[e4].citationMetadata = t3.citationMetadata, n2.candidates[e4].finishReason = t3.finishReason, n2.candidates[e4].finishMessage = t3.finishMessage, n2.candidates[e4].safetyRatings = t3.safetyRatings, t3.content && t3.content.parts) {
          n2.candidates[e4].content || (n2.candidates[e4].content = { role: t3.content.role || "user", parts: [{ text: "" }] });
          for (const s2 of t3.content.parts)
            s2.text && (n2.candidates[e4].content.parts[0].text += s2.text);
        }
      }
  return n2;
}
async function A(t2, e2, n2, s2) {
  const i2 = new h(e2, u.STREAM_GENERATE_CONTENT, t2, true);
  return S(await E(i2, JSON.stringify(n2), s2));
}
async function N(t2, e2, n2, s2) {
  const i2 = new h(e2, u.GENERATE_CONTENT, t2, false), o2 = await E(i2, JSON.stringify(n2), s2);
  return { response: l(await o2.json()) };
}
function R(t2, e2) {
  let n2 = [];
  if ("string" == typeof t2)
    n2 = [{ text: t2 }];
  else
    for (const e3 of t2)
      "string" == typeof e3 ? n2.push({ text: e3 }) : n2.push(e3);
  return { role: e2, parts: n2 };
}
function I(t2) {
  if (t2.contents)
    return t2;
  return { contents: [R(t2, "user")] };
}
var v = "SILENT_ERROR";
var M = class {
  constructor(t2, e2, n2, s2) {
    this.model = e2, this.params = n2, this.requestOptions = s2, this._history = [], this._sendPromise = Promise.resolve(), this._apiKey = t2, (null == n2 ? void 0 : n2.history) && (this._history = n2.history.map((t3) => {
      if (!t3.role)
        throw new Error("Missing role for history item: " + JSON.stringify(t3));
      return R(t3.parts, t3.role);
    }));
  }
  async getHistory() {
    return await this._sendPromise, this._history;
  }
  async sendMessage(t2) {
    var e2, n2;
    await this._sendPromise;
    const s2 = R(t2, "user"), i2 = { safetySettings: null === (e2 = this.params) || void 0 === e2 ? void 0 : e2.safetySettings, generationConfig: null === (n2 = this.params) || void 0 === n2 ? void 0 : n2.generationConfig, contents: [...this._history, s2] };
    let o2;
    return this._sendPromise = this._sendPromise.then(() => N(this._apiKey, this.model, i2, this.requestOptions)).then((t3) => {
      var e3;
      if (t3.response.candidates && t3.response.candidates.length > 0) {
        this._history.push(s2);
        const n3 = Object.assign({ parts: [], role: "model" }, null === (e3 = t3.response.candidates) || void 0 === e3 ? void 0 : e3[0].content);
        this._history.push(n3);
      } else {
        const e4 = p(t3.response);
        e4 && console.warn(`sendMessage() was unsuccessful. ${e4}. Inspect response object for details.`);
      }
      o2 = t3;
    }), await this._sendPromise, o2;
  }
  async sendMessageStream(t2) {
    var e2, n2;
    await this._sendPromise;
    const s2 = R(t2, "user"), i2 = { safetySettings: null === (e2 = this.params) || void 0 === e2 ? void 0 : e2.safetySettings, generationConfig: null === (n2 = this.params) || void 0 === n2 ? void 0 : n2.generationConfig, contents: [...this._history, s2] }, o2 = A(this._apiKey, this.model, i2, this.requestOptions);
    return this._sendPromise = this._sendPromise.then(() => o2).catch((t3) => {
      throw new Error(v);
    }).then((t3) => t3.response).then((t3) => {
      if (t3.candidates && t3.candidates.length > 0) {
        this._history.push(s2);
        const e3 = Object.assign({}, t3.candidates[0].content);
        e3.role || (e3.role = "model"), this._history.push(e3);
      } else {
        const e3 = p(t3);
        e3 && console.warn(`sendMessageStream() was unsuccessful. ${e3}. Inspect response object for details.`);
      }
    }).catch((t3) => {
      t3.message !== v && console.error(t3);
    }), o2;
  }
};
var w = class {
  constructor(t2, e2, n2) {
    this.apiKey = t2, e2.model.includes("/") ? this.model = e2.model : this.model = `models/${e2.model}`, this.generationConfig = e2.generationConfig || {}, this.safetySettings = e2.safetySettings || [], this.requestOptions = n2 || {};
  }
  async generateContent(t2) {
    const e2 = I(t2);
    return N(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings }, e2), this.requestOptions);
  }
  async generateContentStream(t2) {
    const e2 = I(t2);
    return A(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings }, e2), this.requestOptions);
  }
  startChat(t2) {
    return new M(this.apiKey, this.model, t2, this.requestOptions);
  }
  async countTokens(t2) {
    const e2 = I(t2);
    return async function(t3, e3, n2, s2) {
      const i2 = new h(e3, u.COUNT_TOKENS, t3, false);
      return (await E(i2, JSON.stringify(Object.assign(Object.assign({}, n2), { model: e3 })), s2)).json();
    }(this.apiKey, this.model, e2);
  }
  async embedContent(t2) {
    const e2 = function(t3) {
      if ("string" == typeof t3 || Array.isArray(t3))
        return { content: R(t3, "user") };
      return t3;
    }(t2);
    return async function(t3, e3, n2, s2) {
      const i2 = new h(e3, u.EMBED_CONTENT, t3, false);
      return (await E(i2, JSON.stringify(n2), s2)).json();
    }(this.apiKey, this.model, e2);
  }
  async batchEmbedContents(t2) {
    return async function(t3, e2, n2, s2) {
      const i2 = new h(e2, u.BATCH_EMBED_CONTENTS, t3, false), o2 = n2.requests.map((t4) => Object.assign(Object.assign({}, t4), { model: e2 }));
      return (await E(i2, JSON.stringify({ requests: o2 }), s2)).json();
    }(this.apiKey, this.model, t2, this.requestOptions);
  }
};
var b = class {
  constructor(t2) {
    this.apiKey = t2;
  }
  getGenerativeModel(t2, e2) {
    if (!t2.model)
      throw new r("Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })");
    return new w(this.apiKey, t2, e2);
  }
};

// src/GeminiService.ts
var Gemini = class {
  constructor(plugin, model) {
    this.model = model || plugin.getSettings().model;
    this.plugin = plugin;
    this.apiKey = plugin.getSettings().apiKey;
    this.genAI = new b(this.apiKey);
  }
  updateApiKey(key) {
    this.apiKey = key;
    this.genAI = new b(this.apiKey);
  }
  startChat(model) {
    return new GeminiChat(
      this.plugin,
      this.genAI.getGenerativeModel({ model: this.model })
    );
  }
  async generate(option) {
    if (!option.prompt || option.prompt.length == 0) {
      return;
    }
    const model = this.genAI.getGenerativeModel({ model: option.model });
    const threshold = this.plugin.getSettings().saftyThreshold;
    model.generationConfig = {
      stopSequences: option.config.stopSequences,
      maxOutputTokens: option.config.maxOutputTokens,
      temperature: option.config.temperature,
      topP: option.config.topP,
      topK: option.config.topK
    };
    model.safetySettings = [
      {
        category: "HARM_CATEGORY_HARASSMENT",
        threshold
      },
      {
        category: "HARM_CATEGORY_DANGEROUS_CONTENT",
        threshold
      },
      {
        category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
        threshold
      },
      {
        category: "HARM_CATEGORY_HATE_SPEECH",
        threshold
      }
    ];
    return await model.generateContentStream(option.prompt);
  }
  async countToken(prompt2) {
    if (!prompt2 || prompt2.length == 0) {
      return 0;
    }
    const model = this.genAI.getGenerativeModel({ model: this.model });
    const { totalTokens } = await model.countTokens(prompt2);
    return totalTokens;
  }
};
var GeminiChat = class {
  constructor(plugin, model) {
    const threshold = plugin.getSettings().saftyThreshold;
    this.model = model;
    const safetySettings = [
      {
        category: "HARM_CATEGORY_HARASSMENT",
        threshold
      },
      {
        category: "HARM_CATEGORY_DANGEROUS_CONTENT",
        threshold
      },
      {
        category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
        threshold
      },
      {
        category: "HARM_CATEGORY_HATE_SPEECH",
        threshold
      }
    ];
    this.session = this.model.startChat({
      history: [],
      safetySettings
    });
  }
  async send(msg) {
    if (!msg) {
      return;
    }
    const result = await this.session.sendMessageStream(msg);
    return result;
  }
};

// src/GeminiExtension.ts
var createStateFiled = () => {
  const f2 = import_state.StateField.define({
    create() {
      return import_view.Decoration.none;
    },
    update(widgets, tr) {
      widgets = widgets.map(tr.changes);
      for (let e2 of tr.effects) {
        if (e2.is(addGemini)) {
          const updated = e2.map(tr.changes) || e2;
          const geminiMark = import_view.Decoration.mark({
            class: "gemini-widget",
            id: e2.value.id,
            tagName: "span"
          });
          widgets = widgets.update({
            add: [
              geminiMark.range(
                updated.value.from,
                updated.value.to
              )
            ]
          });
        }
      }
      return widgets;
    },
    // provide: (field) =>
    //     EditorView.atomicRanges.of((view) => {
    //         return view.state.field(field)
    //     }),
    provide: (field) => import_view.EditorView.decorations.from(field)
  });
  return f2;
};
var GeminiExtension = class {
  constructor(plugin) {
    this.gemini = new Gemini(plugin);
    this.field = createStateFiled();
  }
  updateApiKey(key) {
    this.gemini.updateApiKey(key);
  }
  async generate(view, option) {
    if (option.prompt.length == 0) {
      return;
    }
    let cursor = view.state.selection.main.to;
    let line = view.state.doc.lineAt(cursor);
    let id = nanoid();
    view.dispatch({
      changes: [
        {
          from: line.to,
          // insert a callout block
          insert: "\n\n>[!gemini]+ Gemini\n> "
        }
      ],
      effects: [addGemini.of({ from: line.to, to: line.to, prompt, id })]
    });
    try {
      const result = await this._generate(option);
      let prevChunk = null;
      for await (const chunk of result.stream) {
        if (prevChunk !== null) {
          this.processChunk(view, id, prevChunk.text(), false);
        }
        prevChunk = chunk;
      }
      if (prevChunk !== null) {
        this.processChunk(view, id, prevChunk.text(), true);
      }
    } catch (e2) {
      this.processChunk(
        view,
        id,
        `<span style="color: var(--text-error)">${(e2 == null ? void 0 : e2.toString()) || "Unknown Error"}</span>`,
        true
      );
    }
  }
  processChunk(view, id, text2, last) {
    let to = this.findRangeById(view, id);
    if (to < 0) {
      return;
    }
    const pattern = /\r?\n/g;
    let format = text2.replace(pattern, "\n> ");
    if (last) {
      format += "\n";
    }
    const changes = [
      {
        from: to,
        insert: format
      }
    ];
    view.dispatch({ changes });
  }
  findRangeById(view, id) {
    const range = view.state.field(this.field).iter();
    let deco = range.value;
    let to = -1;
    while (deco) {
      if (deco.spec.id == id) {
        to = range.to - 1;
        break;
      }
      range.next();
      deco = range.value;
    }
    return to;
  }
  async _generate(option) {
    const result = await this.gemini.generate(option);
    return result ? result : { stream: [] };
  }
  getExtension() {
    return this.field;
  }
};
var addGemini = import_state.StateEffect.define({
  map: (value, change) => {
    return {
      from: change.mapPos(value.from),
      to: change.mapPos(value.to, 1),
      prompt,
      id: value.id
    };
  }
});

// src/ChatView.ts
var import_obsidian5 = require("obsidian");

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}

// src/components/ChatComponent.svelte
var import_obsidian4 = require("obsidian");
function add_css2(target) {
  append_styles(target, "svelte-477m8o", ".gemini-chat.svelte-477m8o.svelte-477m8o{display:flex;flex-direction:column;height:100%;width:100%}.gemini-conversation.svelte-477m8o.svelte-477m8o{flex:1 1 0%;width:100%;overflow-y:scroll;scrollbar-width:none}.gemini-conversation.svelte-477m8o.svelte-477m8o::-webkit-scrollbar{display:none}.gemini-conv-item.svelte-477m8o.svelte-477m8o{width:100%;padding:1rem}.gemini-prompt.svelte-477m8o.svelte-477m8o{margin-bottom:10px}.gemini-prompt-wrapper.svelte-477m8o.svelte-477m8o{width:100%;border-width:1px;border-radius:1rem;border-color:var(--text-faint);border-style:solid;border-width:1px;display:flex;padding:0px 10px}.gemini-prompt.svelte-477m8o textarea.svelte-477m8o{max-height:200px;width:100%;overflow-y:hidden;line-height:1.3rem;border:none;resize:none;outline:none}.gemini-prompt.svelte-477m8o textarea.svelte-477m8o:active{border:none;outline:none;box-shadow:none}.gemini-prompt.svelte-477m8o textarea.svelte-477m8o:focus{border:none;outline:none;box-shadow:none}.gemini-btn-send.svelte-477m8o.svelte-477m8o{position:absolute;vertical-align:middle;right:2rem;bottom:1.7rem}.gemini-btn-send.svelte-477m8o svg.svelte-477m8o{stroke:var(--text-faint)}.gemini-conv-icon.svelte-477m8o.svelte-477m8o{width:1.3rem;height:1.3rem;border-radius:50%;margin-right:10px}.gemini-conv-icon.svelte-477m8o svg.svelte-477m8o{width:100%;height:100%;stroke-width:2px}.gemini-conv-line.svelte-477m8o.svelte-477m8o{display:flex;margin-left:auto;margin-right:auto;max-width:50rem;width:100%}.gemini-conv-content.svelte-477m8o.svelte-477m8o{display:flex;flex-direction:column;flex:1 1 0%;-webkit-user-select:text;user-select:text}.gemini-conv-name.svelte-477m8o.svelte-477m8o{font-weight:700;color:#7f7dd1}");
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  return child_ctx;
}
function get_if_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = nanoid();
  child_ctx[22] = constants_0;
  return child_ctx;
}
function create_else_block_1(ctx) {
  let geminiicon;
  let current;
  geminiicon = new GeminiIcon_default({ props: { width: null, height: null } });
  return {
    c() {
      create_component(geminiicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(geminiicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(geminiicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(geminiicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(geminiicon, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let svg;
  let radialGradient0;
  let stop0;
  let stop1;
  let radialGradient0_id_value;
  let radialGradient1;
  let stop2;
  let stop3;
  let radialGradient1_id_value;
  let radialGradient2;
  let stop4;
  let stop5;
  let radialGradient2_id_value;
  let radialGradient3;
  let stop6;
  let stop7;
  let radialGradient3_id_value;
  let radialGradient4;
  let stop8;
  let stop9;
  let radialGradient4_id_value;
  let radialGradient5;
  let stop10;
  let stop11;
  let radialGradient5_id_value;
  let radialGradient6;
  let stop12;
  let stop13;
  let radialGradient6_id_value;
  let radialGradient7;
  let stop14;
  let stop15;
  let stop16;
  let radialGradient7_id_value;
  let clipPath;
  let path0;
  let clipPath_id_value;
  let g1;
  let path1;
  let path2;
  let path2_fill_value;
  let path3;
  let path3_fill_value;
  let path4;
  let path4_fill_value;
  let path5;
  let path5_fill_value;
  let g0;
  let path6;
  let path6_fill_value;
  let path7;
  let path7_fill_value;
  let path8;
  let path8_fill_value;
  let path9;
  let path9_fill_value;
  let g1_clip_path_value;
  return {
    c() {
      svg = svg_element("svg");
      radialGradient0 = svg_element("radialGradient");
      stop0 = svg_element("stop");
      stop1 = svg_element("stop");
      radialGradient1 = svg_element("radialGradient");
      stop2 = svg_element("stop");
      stop3 = svg_element("stop");
      radialGradient2 = svg_element("radialGradient");
      stop4 = svg_element("stop");
      stop5 = svg_element("stop");
      radialGradient3 = svg_element("radialGradient");
      stop6 = svg_element("stop");
      stop7 = svg_element("stop");
      radialGradient4 = svg_element("radialGradient");
      stop8 = svg_element("stop");
      stop9 = svg_element("stop");
      radialGradient5 = svg_element("radialGradient");
      stop10 = svg_element("stop");
      stop11 = svg_element("stop");
      radialGradient6 = svg_element("radialGradient");
      stop12 = svg_element("stop");
      stop13 = svg_element("stop");
      radialGradient7 = svg_element("radialGradient");
      stop14 = svg_element("stop");
      stop15 = svg_element("stop");
      stop16 = svg_element("stop");
      clipPath = svg_element("clipPath");
      path0 = svg_element("path");
      g1 = svg_element("g");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      path5 = svg_element("path");
      g0 = svg_element("g");
      path6 = svg_element("path");
      path7 = svg_element("path");
      path8 = svg_element("path");
      path9 = svg_element("path");
      attr(stop0, "offset", "0");
      attr(stop0, "stop-color", "#fff");
      attr(stop0, "stop-opacity", ".4");
      attr(stop1, "offset", "1");
      attr(stop1, "stop-opacity", ".1");
      attr(radialGradient0, "id", radialGradient0_id_value = /*bid*/
      ctx[22] + "_bottom_left");
      attr(radialGradient0, "cx", "0");
      attr(radialGradient0, "cy", "0");
      attr(radialGradient0, "gradientTransform", "matrix(-59 -225 150 -39 161.4 470)");
      attr(radialGradient0, "gradientUnits", "userSpaceOnUse");
      attr(radialGradient0, "r", "1");
      attr(stop2, "offset", "0");
      attr(stop2, "stop-color", "#fff");
      attr(stop2, "stop-opacity", ".6");
      attr(stop3, "offset", "1");
      attr(stop3, "stop-color", "#fff");
      attr(stop3, "stop-opacity", ".1");
      attr(radialGradient1, "id", radialGradient1_id_value = /*bid*/
      ctx[22] + "_top-right");
      attr(radialGradient1, "cx", "0");
      attr(radialGradient1, "cy", "0");
      attr(radialGradient1, "gradientTransform", "matrix(50 -379 280 37 360 374.2)");
      attr(radialGradient1, "gradientUnits", "userSpaceOnUse");
      attr(radialGradient1, "r", "1");
      attr(stop4, "offset", "0");
      attr(stop4, "stop-color", "#fff");
      attr(stop4, "stop-opacity", ".8");
      attr(stop5, "offset", "1");
      attr(stop5, "stop-color", "#fff");
      attr(stop5, "stop-opacity", ".4");
      attr(radialGradient2, "id", radialGradient2_id_value = /*bid*/
      ctx[22] + "_top-left");
      attr(radialGradient2, "cx", "0");
      attr(radialGradient2, "cy", "0");
      attr(radialGradient2, "gradientTransform", "matrix(69 -319 218 47 175.4 307)");
      attr(radialGradient2, "gradientUnits", "userSpaceOnUse");
      attr(radialGradient2, "r", "1");
      attr(stop6, "offset", "0");
      attr(stop6, "stop-color", "#fff");
      attr(stop6, "stop-opacity", ".3");
      attr(stop7, "offset", "1");
      attr(stop7, "stop-opacity", ".3");
      attr(radialGradient3, "id", radialGradient3_id_value = /*bid*/
      ctx[22] + "_bottom-right");
      attr(radialGradient3, "cx", "0");
      attr(radialGradient3, "cy", "0");
      attr(radialGradient3, "gradientTransform", "matrix(-96 -163 187 -111 335.3 512.2)");
      attr(radialGradient3, "gradientUnits", "userSpaceOnUse");
      attr(radialGradient3, "r", "1");
      attr(stop8, "offset", "0");
      attr(stop8, "stop-color", "#fff");
      attr(stop8, "stop-opacity", "0");
      attr(stop9, "offset", "1");
      attr(stop9, "stop-color", "#fff");
      attr(stop9, "stop-opacity", ".2");
      attr(radialGradient4, "id", radialGradient4_id_value = /*bid*/
      ctx[22] + "_top-edge");
      attr(radialGradient4, "cx", "0");
      attr(radialGradient4, "cy", "0");
      attr(radialGradient4, "gradientTransform", "matrix(-36 166 -112 -24 310 128.2)");
      attr(radialGradient4, "gradientUnits", "userSpaceOnUse");
      attr(radialGradient4, "r", "1");
      attr(stop10, "offset", "0");
      attr(stop10, "stop-color", "#fff");
      attr(stop10, "stop-opacity", ".2");
      attr(stop11, "offset", "1");
      attr(stop11, "stop-color", "#fff");
      attr(stop11, "stop-opacity", ".4");
      attr(radialGradient5, "id", radialGradient5_id_value = /*bid*/
      ctx[22] + "_left-edge");
      attr(radialGradient5, "cx", "0");
      attr(radialGradient5, "cy", "0");
      attr(radialGradient5, "gradientTransform", "matrix(88 89 -190 187 111 220.2)");
      attr(radialGradient5, "gradientUnits", "userSpaceOnUse");
      attr(radialGradient5, "r", "1");
      attr(stop12, "offset", "0");
      attr(stop12, "stop-color", "#fff");
      attr(stop12, "stop-opacity", ".2");
      attr(stop13, "offset", "1");
      attr(stop13, "stop-color", "#fff");
      attr(stop13, "stop-opacity", ".3");
      attr(radialGradient6, "id", radialGradient6_id_value = /*bid*/
      ctx[22] + "_bottom-edge");
      attr(radialGradient6, "cx", "0");
      attr(radialGradient6, "cy", "0");
      attr(radialGradient6, "gradientTransform", "matrix(9 130 -276 20 215 284)");
      attr(radialGradient6, "gradientUnits", "userSpaceOnUse");
      attr(radialGradient6, "r", "1");
      attr(stop14, "offset", "0");
      attr(stop14, "stop-color", "#fff");
      attr(stop14, "stop-opacity", ".2");
      attr(stop15, "offset", ".5");
      attr(stop15, "stop-color", "#fff");
      attr(stop15, "stop-opacity", ".2");
      attr(stop16, "offset", "1");
      attr(stop16, "stop-color", "#fff");
      attr(stop16, "stop-opacity", ".3");
      attr(radialGradient7, "id", radialGradient7_id_value = /*bid*/
      ctx[22] + "_middle-edge");
      attr(radialGradient7, "cx", "0");
      attr(radialGradient7, "cy", "0");
      attr(radialGradient7, "gradientTransform", "matrix(-198 -104 327 -623 400 399.2)");
      attr(radialGradient7, "gradientUnits", "userSpaceOnUse");
      attr(radialGradient7, "r", "1");
      attr(path0, "d", "M.2.2h512v512H.2z");
      attr(clipPath, "id", clipPath_id_value = /*bid*/
      ctx[22] + "_clip");
      attr(path1, "d", "M382.3 475.6c-3.1 23.4-26 41.6-48.7 35.3-32.4-8.9-69.9-22.8-103.6-25.4l-51.7-4a34 34 0 0 1-22-10.2l-89-91.7a34 34 0 0 1-6.7-37.7s55-121 57.1-127.3c2-6.3 9.6-61.2 14-90.6 1.2-7.9 5-15 11-20.3L248 8.9a34.1 34.1 0 0 1 49.6 4.3L386 125.6a37 37 0 0 1 7.6 22.4c0 21.3 1.8 65 13.6 93.2 11.5 27.3 32.5 57 43.5 71.5a17.3 17.3 0 0 1 1.3 19.2 1494 1494 0 0 1-44.8 70.6c-15 22.3-21.9 49.9-25 73.1z");
      attr(path1, "fill", "#6c31e3");
      attr(path2, "d", "M165.9 478.3c41.4-84 40.2-144.2 22.6-187-16.2-39.6-46.3-64.5-70-80-.6 2.3-1.3 4.4-2.2 6.5L60.6 342a34 34 0 0 0 6.6 37.7l89.1 91.7a34 34 0 0 0 9.6 7z");
      attr(path2, "fill", path2_fill_value = "url(#" + /*bid*/
      ctx[22] + "_bottom-left)");
      attr(path3, "d", "M278.4 307.8c11.2 1.2 22.2 3.6 32.8 7.6 34 12.7 65 41.2 90.5 96.3 1.8-3.1 3.6-6.2 5.6-9.2a1536 1536 0 0 0 44.8-70.6 17 17 0 0 0-1.3-19.2c-11-14.6-32-44.2-43.5-71.5-11.8-28.2-13.5-72-13.6-93.2 0-8.1-2.6-16-7.6-22.4L297.6 13.2a34 34 0 0 0-1.5-1.7 96 96 0 0 1 2 54 198.3 198.3 0 0 1-17.6 41.3l-7.2 14.2a171 171 0 0 0-19.4 71c-1.2 29.4 4.8 66.4 24.5 115.8z");
      attr(path3, "fill", path3_fill_value = "url(#" + /*bid*/
      ctx[22] + "_top-right)");
      attr(path4, "d", "M278.4 307.8c-19.7-49.4-25.8-86.4-24.5-115.9a171 171 0 0 1 19.4-71c2.3-4.8 4.8-9.5 7.2-14.1 7.1-13.9 14-27 17.6-41.4a96 96 0 0 0-2-54A34.1 34.1 0 0 0 248 9l-105.4 94.8a34.1 34.1 0 0 0-10.9 20.3l-12.8 85-.5 2.3c23.8 15.5 54 40.4 70.1 80a147 147 0 0 1 7.8 24.8c28-6.8 55.7-11 82.1-8.3z");
      attr(path4, "fill", path4_fill_value = "url(#" + /*bid*/
      ctx[22] + "_top-left)");
      attr(path5, "d", "M333.6 511c22.7 6.2 45.6-12 48.7-35.4a187 187 0 0 1 19.4-63.9c-25.6-55-56.5-83.6-90.4-96.3-36-13.4-75.2-9-115 .7 8.9 40.4 3.6 93.3-30.4 162.2 4 1.8 8.1 3 12.5 3.3 0 0 24.4 2 53.6 4.1 29 2 72.4 17.1 101.6 25.2z");
      attr(path5, "fill", path5_fill_value = "url(#" + /*bid*/
      ctx[22] + "_bottom-right)");
      attr(path6, "d", "M254.1 190c-1.3 29.2 2.4 62.8 22.1 112.1l-6.2-.5c-17.7-51.5-21.5-78-20.2-107.6a174.7 174.7 0 0 1 20.4-72c2.4-4.9 8-14.1 10.5-18.8 7.1-13.7 11.9-21 16-33.6 5.7-17.5 4.5-25.9 3.8-34.1 4.6 29.9-12.7 56-25.7 82.4a177.1 177.1 0 0 0-20.7 72z");
      attr(path6, "fill", path6_fill_value = "url(#" + /*bid*/
      ctx[22] + "_top-edge)");
      attr(path7, "d", "M194.3 293.4c2.4 5.4 4.6 9.8 6 16.5L195 311c-2.1-7.8-3.8-13.4-6.8-20-17.8-42-46.3-63.6-69.7-79.5 28.2 15.2 57.2 39 75.7 81.9z");
      attr(path7, "fill", path7_fill_value = "url(#" + /*bid*/
      ctx[22] + "_left-edge)");
      attr(path8, "d", "M200.6 315.1c9.8 46-1.2 104.2-33.6 160.9 27.1-56.2 40.2-110.1 29.3-160z");
      attr(path8, "fill", path8_fill_value = "url(#" + /*bid*/
      ctx[22] + "_bottom-edge)");
      attr(path9, "d", "M312.5 311c53.1 19.9 73.6 63.6 88.9 100-19-38.1-45.2-80.3-90.8-96-34.8-11.8-64.1-10.4-114.3 1l-1.1-5c53.2-12.1 81-13.5 117.3 0z");
      attr(path9, "fill", path9_fill_value = "url(#" + /*bid*/
      ctx[22] + "_middle-edge)");
      attr(g0, "clip-rule", "evenodd");
      attr(g0, "fill-rule", "evenodd");
      attr(g1, "clip-path", g1_clip_path_value = "url(#" + /*bid*/
      ctx[22] + "_clip)");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 512 512");
      attr(svg, "class", "svelte-477m8o");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, radialGradient0);
      append(radialGradient0, stop0);
      append(radialGradient0, stop1);
      append(svg, radialGradient1);
      append(radialGradient1, stop2);
      append(radialGradient1, stop3);
      append(svg, radialGradient2);
      append(radialGradient2, stop4);
      append(radialGradient2, stop5);
      append(svg, radialGradient3);
      append(radialGradient3, stop6);
      append(radialGradient3, stop7);
      append(svg, radialGradient4);
      append(radialGradient4, stop8);
      append(radialGradient4, stop9);
      append(svg, radialGradient5);
      append(radialGradient5, stop10);
      append(radialGradient5, stop11);
      append(svg, radialGradient6);
      append(radialGradient6, stop12);
      append(radialGradient6, stop13);
      append(svg, radialGradient7);
      append(radialGradient7, stop14);
      append(radialGradient7, stop15);
      append(radialGradient7, stop16);
      append(svg, clipPath);
      append(clipPath, path0);
      append(svg, g1);
      append(g1, path1);
      append(g1, path2);
      append(g1, path3);
      append(g1, path4);
      append(g1, path5);
      append(g1, g0);
      append(g0, path6);
      append(g0, path7);
      append(g0, path8);
      append(g0, path9);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_else_block(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Gemini");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block(ctx) {
  let t2;
  return {
    c() {
      t2 = text("You");
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block(ctx) {
  let div5;
  let div4;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t0;
  let div3;
  let div1;
  let t1;
  let div2;
  let t2;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*conv*/
      ctx2[19].role == "user"
    )
      return 0;
    return 1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 0)
      return get_if_ctx(ctx2);
    return ctx2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  function select_block_type_1(ctx2, dirty) {
    if (
      /*conv*/
      ctx2[19].role == "user"
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      if_block1.c();
      t1 = space();
      div2 = element("div");
      div2.innerHTML = ``;
      t2 = space();
      attr(div0, "class", "gemini-conv-icon svelte-477m8o");
      attr(div1, "class", "gemini-conv-name svelte-477m8o");
      attr(div2, "class", "markdown-rendered gemini-conv-text");
      attr(div3, "class", "gemini-conv-content svelte-477m8o");
      attr(div4, "class", "gemini-conv-line svelte-477m8o");
      attr(div5, "class", "gemini-conv-item svelte-477m8o");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      if_block1.m(div1, null);
      append(div3, t1);
      append(div3, div2);
      append(div5, t2);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx2, current_block_type_index));
          if_block0.c();
        } else {
        }
        transition_in(if_block0, 1);
        if_block0.m(div0, null);
      }
      if (current_block_type !== (current_block_type = select_block_type_1(ctx2, dirty))) {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div1, null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      if_blocks[current_block_type_index].d();
      if_block1.d();
    }
  };
}
function create_fragment3(ctx) {
  let div3;
  let div0;
  let t0;
  let div2;
  let div1;
  let textarea_1;
  let t1;
  let span;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*history*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      textarea_1 = element("textarea");
      t1 = space();
      span = element("span");
      span.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-corner-down-left svelte-477m8o"><polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path></svg>`;
      attr(div0, "class", "gemini-conversation svelte-477m8o");
      attr(textarea_1, "placeholder", "Chat with Gemini..");
      attr(textarea_1, "rows", "1");
      attr(textarea_1, "class", "svelte-477m8o");
      attr(span, "class", "gemini-btn-send svelte-477m8o");
      attr(div1, "class", "gemini-prompt-wrapper svelte-477m8o");
      attr(div2, "class", "gemini-prompt svelte-477m8o");
      attr(div3, "class", "gemini-chat svelte-477m8o");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      append(div3, t0);
      append(div3, div2);
      append(div2, div1);
      append(div1, textarea_1);
      ctx[9](textarea_1);
      append(div1, t1);
      append(div1, span);
      ctx[10](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            textarea_1,
            "input",
            /*textchange*/
            ctx[3]
          ),
          listen(
            textarea_1,
            "keypress",
            /*enter*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*history*/
      2) {
        each_value = ensure_array_like(
          /*history*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_each(each_blocks, detaching);
      ctx[9](null);
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { gemini } = $$props;
  let { view } = $$props;
  let { app } = $$props;
  let container;
  let history = [];
  let chat = gemini.startChat("gemini-pro");
  const clear = () => {
    var _a;
    chat = gemini.startChat("gemini-pro");
    (_a = container === null || container === void 0 ? void 0 : container.firstElementChild) === null || _a === void 0 ? void 0 : _a.empty();
    $$invalidate(1, history = []);
  };
  let textarea;
  onMount(() => {
    setTimeout(
      () => {
        textarea === null || textarea === void 0 ? void 0 : textarea.focus();
      },
      1e3
    );
  });
  let generating = false;
  const textchange = () => {
    const height = textarea.scrollHeight;
    $$invalidate(2, textarea.style.height = `${height}px`, textarea);
  };
  const addUserMsg = (msg) => __awaiter(void 0, void 0, void 0, function* () {
    const index = history.length;
    $$invalidate(1, history = [...history, { role: "user", parts: msg }]);
    yield tick();
    renderMd(index);
  });
  const renderMd = (index) => __awaiter(void 0, void 0, void 0, function* () {
    yield tick();
    const els = container.getElementsByClassName("gemini-conv-text");
    if (els.length > 0) {
      const el = els.item(index);
      if (el) {
        el.empty();
        yield import_obsidian4.MarkdownRenderer.render(app, history[index].parts, el, "", view);
        el.scrollIntoView({
          behavior: "smooth",
          block: "end",
          inline: "nearest"
        });
      }
    }
  });
  const send = () => __awaiter(void 0, void 0, void 0, function* () {
    var _a, e_1, _b, _c;
    if (generating) {
      return;
    }
    generating = true;
    if (textarea.value) {
      const msg = textarea.value;
      $$invalidate(2, textarea.value = "", textarea);
      yield addUserMsg(msg);
      let index = history.length;
      $$invalidate(1, history = [...history, { role: "model", parts: "" }]);
      yield addLoading(index);
      try {
        const result = yield chat.send(msg);
        let count = 0;
        try {
          for (var _d = true, _e = __asyncValues(result.stream), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
            _c = _f.value;
            _d = false;
            const chunk = _c;
            if (count == 0) {
              $$invalidate(1, history[index].parts = chunk.text(), history);
            } else {
              $$invalidate(1, history[index].parts += chunk.text(), history);
            }
            yield renderMd(index);
            count++;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = _e.return))
              yield _b.call(_e);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      } catch (e2) {
        yield renderError(index, e2);
      } finally {
        generating = false;
        removeLoading(index);
      }
    }
  });
  const addLoading = (i2) => __awaiter(void 0, void 0, void 0, function* () {
    yield tick();
    const els = container.getElementsByClassName("gemini-conv-name");
    if (els.length > 0) {
      const el = els.item(i2);
      if (el) {
        const div = document.createElement("span");
        div.addClass("gemini-ripple");
        el.append(div);
      }
    }
  });
  const removeLoading = (i2) => {
    var _a;
    const els = container.getElementsByClassName("gemini-conv-name");
    if (els.length > 0) {
      const el = els.item(i2);
      if (el) {
        (_a = el.firstElementChild) === null || _a === void 0 ? void 0 : _a.remove();
      }
    }
  };
  const renderError = (i2, e2) => __awaiter(void 0, void 0, void 0, function* () {
    if (!history[i2]) {
      $$invalidate(1, history = [
        ...history,
        {
          role: "model",
          parts: "",
          error: e2.toString()
        }
      ]);
    } else {
      $$invalidate(1, history[i2].error = e2.toString(), history);
    }
    yield tick();
    const els = container.getElementsByClassName("gemini-conv-text");
    if (els.length > 0) {
      const el = els.item(i2);
      if (el) {
        el.empty();
        const div = document.createElement("div");
        div.setText(history[i2].error || "");
        div.addClass("gemini-err-message");
        el.append(div);
        el.scrollIntoView({
          behavior: "smooth",
          block: "end",
          inline: "nearest"
        });
      }
    }
  });
  const enter = (e2) => {
    if (e2.key === "Enter") {
      if (e2.shiftKey || e2.altKey) {
        return;
      } else {
        send();
        $$invalidate(2, textarea.style.height = `inherit`, textarea);
        e2.preventDefault();
      }
    }
  };
  function textarea_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      textarea = $$value;
      $$invalidate(2, textarea);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(0, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("gemini" in $$props2)
      $$invalidate(5, gemini = $$props2.gemini);
    if ("view" in $$props2)
      $$invalidate(6, view = $$props2.view);
    if ("app" in $$props2)
      $$invalidate(7, app = $$props2.app);
  };
  return [
    container,
    history,
    textarea,
    textchange,
    enter,
    gemini,
    view,
    app,
    clear,
    textarea_1_binding,
    div3_binding
  ];
}
var ChatComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { gemini: 5, view: 6, app: 7, clear: 8 }, add_css2);
  }
  get clear() {
    return this.$$.ctx[8];
  }
};
var ChatComponent_default = ChatComponent;

// src/ChatView.ts
var VIEW_TYPE_GEMINI_CHAT = "gemini-chat-view";
var ChatView = class extends import_obsidian5.ItemView {
  constructor(plugin, leaf) {
    super(leaf);
    this.plugin = plugin;
    this.icon = "message-circle";
    this.navigation = false;
    this.addAction("x-square", "Clear", () => {
      var _a;
      (_a = this.component) == null ? void 0 : _a.clear();
    });
  }
  getViewType() {
    return VIEW_TYPE_GEMINI_CHAT;
  }
  getDisplayText() {
    return "Gemini Chat";
  }
  async onOpen() {
    var _a;
    this.contentEl.style.overflowY = "hidden";
    this.component = new ChatComponent_default({
      target: this.contentEl,
      props: {
        gemini: (_a = this.plugin.gemini) == null ? void 0 : _a.gemini,
        view: this,
        app: this.plugin.app
      }
    });
  }
  async onClose() {
    var _a;
    (_a = this.component) == null ? void 0 : _a.$destroy();
  }
};

// src/main.ts
var GeminiAssistantPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.cmExtension = [];
  }
  getSettings() {
    var _a;
    return ((_a = this.settings) == null ? void 0 : _a.getSettings()) || DEFAULT_SETTINGS;
  }
  async updateSettings(newSettings, refresh = false) {
    var _a;
    await ((_a = this.settings) == null ? void 0 : _a.updateSettings(newSettings, refresh));
  }
  async onload() {
    const settings = { ...DEFAULT_SETTINGS, ...await this.loadData() };
    this.settings = new GeminiSettings(this, settings);
    this.addSettingTab(this.settings);
    this.cmExtension = [];
    this.registerEditorExtension(this.cmExtension);
    this.updateEditorExtensions();
    this.registerView(
      VIEW_TYPE_GEMINI_CHAT,
      (leaf) => new ChatView(this, leaf)
    );
    this.addCommand({
      id: "gemini-assistant",
      name: "Open assistant",
      editorCallback: (editor, ctx) => {
        if (ctx instanceof import_obsidian6.MarkdownView) {
          new AssistantSuggestor(this, editor, ctx);
        }
      }
    });
    this.addRibbonIcon("message-circle", "New Gemini chat", () => {
      this.newChatView();
    });
    this.addCommand({
      id: "gemini-chat",
      name: "New Gemini chat",
      callback: () => {
        this.newChatView();
      }
    });
  }
  updateApiKey(key) {
    var _a;
    (_a = this.gemini) == null ? void 0 : _a.updateApiKey(key);
  }
  async newChatView() {
    let { workspace } = this.app;
    let leaf = workspace.getLeaf();
    await leaf.setViewState({
      type: VIEW_TYPE_GEMINI_CHAT,
      active: true
    });
    workspace.revealLeaf(leaf);
  }
  async activateChatView() {
    let { workspace } = this.app;
    let leaf = null;
    let leaves = workspace.getLeavesOfType(VIEW_TYPE_GEMINI_CHAT);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({
        type: VIEW_TYPE_GEMINI_CHAT,
        active: true
      });
    }
    workspace.revealLeaf(leaf);
  }
  updateEditorExtensions() {
    this.gemini = new GeminiExtension(this);
    this.cmExtension.length = 0;
    this.cmExtension.push(this.gemini.getExtension());
    this.app.workspace.updateOptions();
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
